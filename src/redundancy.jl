######################
# Redundancy removal #
######################

# Redundancy
export detecthlinearity!, detectvlinearity!, dim, detectvlinearity, detect_new_lines
export isredundant, removevredundancy!, removevredundancy, removehredundancy!, gethredundantindices, getvredundantindices

"""
    detecthlinearity!(p::VRep)

Detects all the hyperplanes contained in the H-representation and remove all redundant hyperplanes.

## Examples
The representation
```julia
h = HalfSpace([1, 1], 1]) ∩ HalfSpace([-1, -1], -1)
```
contains the hyperplane `HyperPlane([1, 1], 1)`.
"""
detecthlinearity!(p::HRep) = error("detecthlinearity! not implemented for $(typeof(p))")
detecthlinearity!(p::Polyhedron) = sethrep!(p, removeduplicates(hrep(p)))

"""
    detectvlinearity!(p::VRep)

Detects all the lines contained in the V-representation and remove all redundant lines.

## Examples
The representation
```julia
v = conichull([1, 1], [-1, -1])
```
contains the line `Line([1, 1])`.
"""
detectvlinearity!(p::VRep) = error("detectvlinearity! not implemented for $(typeof(p))")
detectvlinearity!(p::Polyhedron, solver=default_solver(p)) = setvrep!(p, detectvlinearity(vrep(p), solver))

# No ray so no line
function detectvlinearity!(p::VPolytope) end
detectvlinearity(p::VPolytope) = p

function detect_opposite_rays(aff, rs, vrep)
    newlin = true
    for i in 1:fulldim(vrep) # could use `while newlin` but `for`-loop is safer.
        newlin || break
        newlin = false
        empty!(rs)
        # Project each ray orthogonal to the line space.
        # Remove rays that become zero and detect new lines
        # with rays that becomes opposite to each other.
        for r in rays(vrep)
            newlin |= Polyhedra.vrupdatedup!(aff, rs, r)
        end
    end
end

"""
    detect_new_lines(lines, rays, solver)

Given a cone generated by the lines in `lines` and the rays in `rays`, detect whether a new line can be generated from the rays in `rays` using an linear program solved by `solver`.
The method is as follows (suppose `lines` is empty for simplicity).
This is the function automatically called by `removevredundancy` if a solver is provided.

If there was a line `l` in the cone, it would mean that there exist `μ >= 0` and `ν >= 0` such that
`Σ μ_i r_i = l` and `Σ ν_i r_i = -l`. We deduce from this that `Σ λ_i r_i = 0` where `λ = μ + ν`.

Conversely, if there are `λ >= 0` such that `Σ λ_i r_i = 0` then let `j` be the index of `λ` with largest magnitude
(to make sure it is nonzero).
We have `Σ_{i != j} λ_i/λ_j r_i = -r_j`. As both `r_j` and `-r_j` are in the cone,
`r_j` generates a line in the cone.
However, this means that we now have `Σ_{i != j} λ_i/λ_j r_i ≡ 0 (mod r_j)` so if there is another `λ_i`
with nonzero value, we can transform it to a line as well.
In summary, we have a line `r_i` for each `i` such that `λ_i != 0`.

The dual program is:
max z
    r_i'x >= z
When the primal is feasible, the dual program may still be feasible.
We know that `z = 0` by strong duality as the objective value needs to be equal to the objective of the primal which is zero.
So the constraints are `r_i'x >= 0`. If we have `r_i'x > 0` for some `i`, it means that `-r_i` does not belong to the cone
hence `r_i` can be dropped for the purpose of searching for lines.

## Note

In CDDLib, the dual program is solved, if the objective value is zero then linearity are found
by, for each `i` such that `r_i'x = 0`, solve an LP to find whether `-r_i` belongs to the cone.
CDDLib ignores the primal results provided in `λ` which directly gives linearity without the need
to solve an LP for each ray.
This method is therefore significantly more efficient as it's complexity is `O(dimension of linespace)` which is upper
bounded by `O(fulldim)` while the method of CDDLib is `O(number of rays)`.
"""
function detect_new_lines(lines, rays, solver)
    isempty(rays) && return
    model, T = Polyhedra.layered_optimizer(solver)
    is_lin = falses(length(rays))
    active = trues(length(rays))
    λ = MOI.add_variables(model, length(rays))
    cλ = [
        MOI.add_constraint(model, MOI.SingleVariable(λ), MOI.GreaterThan(zero(T)))
        for λ in λ
    ]
    n = length(Polyhedra.coord(first(rays)))
    func = MOI.VectorAffineFunction(
        [MOI.VectorAffineTerm(i, MOI.ScalarAffineTerm{T}(Polyhedra.coord(ray)[i], λ))
         for (ray, λ) in zip(rays, λ) for i in 1:n],
        zeros(T, n)
    )
    if !isempty(lines)
        η = MOI.add_variables(solver, length(lines))
        for (line, η) in zip(lines, η)
            for i in 1:n
                push!(func.terms, MOI.VectorAffineTerm(i, MOI.ScalarAffineTerm{T}(line[i], η)))
            end
        end
    end
    MOI.add_constraint(model, func, MOI.Zeros(n))
    # Break homogeneity of the problem with sum(λ) == 1
    sum_func = MOI.ScalarAffineFunction(
        MOI.ScalarAffineTerm.(one(T), λ),
        zero(T)
    )
    sum_con = MOI.add_constraint(model, sum_func, MOI.EqualTo(1.0))
    for i in 1:n # safer than `while ...`
        (count(is_lin) == length(is_lin) || iszero(count(active))) && break
        Polyhedra.is_feasible(model, "detecting new linearity.") || break
        for i in eachindex(λ)
            if active[i] && !is_lin[i]
                if !Polyhedra.isapproxzero(MOI.get(model, MOI.VariablePrimal(), λ[i]))
                    # `λ_i > 0`, we know that `-r_i` belongs to the cone so we transform the ray into a line.
                    push!(lines, Polyhedra.line(rays[i]))
                    MOI.delete(model, cλ[i])
                    is_lin[i] = true
                    MOI.modify(model, sum_con, MOI.ScalarCoefficientChange(λ[i], 0.0))
                elseif !Polyhedra.isapproxzero(MOI.get(model, MOI.ConstraintDual(), cλ[i]))
                    # `r_i'x > 0`, we know that `r_i` does not belong to the cone so we just drop the ray from the search for lines.
                    MOI.delete(model, λ[i])
                    active[i] = false
                end # otherwise, we are still uncertain about this ray and we'll do a new solve.
            end
        end
    end
    deleteat!(rays, findall(is_lin))
    return
end

struct OppositeRaysMockOptimizer end
function _detectvlinearity(vrep::VRepresentation, solver)
    aff = linespace(vrep, true)
    if hasrays(vrep)
        if solver === nothing
            @warn("Cannot detect exact linearity as no solver was provided and the polyhedron is not bounded.\n" *
                  "We will assume that there is no more line to be detected from the rays, set a solver if you believe that the polyhedron may have more linearity.\n" *
                  no_solver_help())
            solver = OppositeRaysMockOptimizer
        end
        if solver == OppositeRaysMockOptimizer
            rs = raytype(vrep)[]
            detect_opposite_rays(aff, rs, vrep)
        else
            rs = collect(rays(vrep))
            detect_new_lines(aff.lines, rs, solver)
        end
    else
        rs = rays(vrep)
    end
    return removeduplicates(aff), rs
end
function detectvlinearity(vrep::VRepresentation, solver)
    aff, rays = _detectvlinearity(vrep, solver)
    typeof(vrep)(Polyhedra.FullDim(vrep), preps(vrep)..., aff.lines, rays)
end

"""
    dim(h::HRep, current=false)

Returns the dimension of the affine hull of the polyhedron.
That is the number of non-redundant hyperplanes that define it.
If `current` is `true` then it simply returns the dimension according the current number of hyperplanes, assuming that the H-linearity has already been detected.
Otherwise, it first calls [`detecthlinearity!`](@ref).
"""
function dim(h::HRep, current=false)
    if !current
        detecthlinearity!(h)
    end
    fulldim(h) - nhyperplanes(h)
end

"""
    isredundant(p::Rep, idx::Index; strongly=false)

Return a `Bool` indicating whether the element with index `idx` can be removed without changing the polyhedron represented by `p`.
If `strongly` is `true`,
* if `idx` is an H-representation element `h`, it returns `true` only if no V-representation element of `p` is in the hyperplane of `h`.
* if `idx` is a V-representation element `v`, it returns `true` only if `v` is in the relative interior of `p`.
"""
function isredundant end

"""
    removehredundancy!(p::HRep)

Removes the elements of the H-representation of `p` that can be removed without changing the polyhedron represented by `p`. That is, it only keeps the halfspaces corresponding to facets of the polyhedron.
"""
function removehredundancy! end
function removehredundancy!(p::Polyhedron)
    detectvlinearity!(p)
    detecthlinearity!(p)
    sethrep!(p, removehredundancy(hrep(p), vrep(p)))
end

_optimize!(model::JuMP.Model) = JuMP.optimize!(model)
_optimize!(model::MOI.ModelLike) = MOI.optimize!(model)

function is_feasible(model, message)
    @assert MOI.get(model, MOI.ObjectiveSense()) == MOI.FEASIBILITY_SENSE
    _optimize!(model)
    status = MOI.get(model, MOI.TerminationStatus())
    # The objective sense is `MOI.FEASIBILITY_SENSE` so
    # `INFEASIBLE_OR_UNBOUNDED` means infeasible because it cannot be
    # unbounded
    if status == MOI.INFEASIBLE || status == MOI.INFEASIBLE_OR_UNBOUNDED
        return false
    elseif status == MOI.OPTIMAL
        return true
    else
        error("Solver returned $term when ", message, " Solver specific status: ", MOI.get(model, MOI.RawStatusString()))
    end
end

"""
    removevredundancy!(p::VRep; strongly=false)

Removes the elements of the V-representation of `p` that can be removed without
changing the polyhedron represented by `p`. That is, it only keeps the extreme
points and rays. This operation is often called "convex hull" as the remaining
points are the extreme points of the convex hull of the initial set of points.
If `strongly=true`, weakly redundant points, i.e., points that are not extreme
but are not in the relative interior either, may be kept.
"""
function removevredundancy! end
function removevredundancy!(p::Polyhedron; strongly=false)
    solver = nothing
    if !strongly && !hrepiscomputed(p) && supportssolver(typeof(p))
        solver = default_solver(p)
        if solver === nothing
            @warn("`removevredundancy` will trigger the computation of the" *
                  " H-representation, which is computationally demanding" *
                  " because no solver was provided to the library. If this is" *
                  " expected, call `computehrep!` explicitely before calling" *
                  " this function to remove this warning.")
        end
    end
    if solver === nothing
        detecthlinearity!(p)
        detectvlinearity!(p)
        setvrep!(p, removevredundancy(vrep(p), hrep(p), strongly=strongly))
    else
        detectvlinearity!(p)
        setvrep!(p, removevredundancy(vrep(p), solver))
    end
end

function nonredundant_elements(vr::VRepresentation, model, hull, z, elements, indices, λ)
    _fill_hull(hull, λ, vr, indices)
    crefs = @constraint(model, z .== hull)
    for idx in indices
        if JuMP.has_lower_bound(λ[idx])
            lb = JuMP.lower_bound(λ[idx])
            JuMP.delete_lower_bound(λ[idx])
        else
            lb = nothing
        end
        JuMP.fix(λ[idx], 0.0)
        element = get(vr, idx)
        for (zi, xi) in zip(z, coord(element))
            JuMP.fix(zi, xi)
        end
        if !isone(length(indices)) &&
            is_feasible(model, "attempting to determine whether $element of index $index is redundant.")
            lb = nothing
            JuMP.delete(model, λ[idx])
            for aff in hull
                # TODO Add a function in JuMP.AffExpr API for that instead of using this hack
                delete!(aff.terms, λ[idx])
            end
        else
            push!(elements, element)
            JuMP.unfix(λ[idx])
        end
        if lb !== nothing
            JuMP.set_lower_bound(λ[idx], 0.0)
        end
    end
    for cref in crefs
        JuMP.delete(model, cref)
    end
end
function nonredundant_lines(vr::VPolytope, model, hull, z)
    return tuple()
end
function nonredundant_lines(vr::VRepresentation, model, hull, z)
    nr_lines = linetype(vr)[]
    if haslines(vr)
        lines_idx = collect(eachindex(lines(vr)))
        λ = @variable(model, [lines_idx])
        nonredundant_elements(vr, model, hull, z, nr_lines, lines_idx, λ)
    end
    return (nr_lines,)
end
function nonredundant_rays(vr::VLinearSpace, model, hull, z)
    return tuple()
end
function nonredundant_rays(vr::VPolytope, model, hull, z)
    return tuple()
end
function nonredundant_rays(vr::VRepresentation, model, hull, z)
    nr_rays = raytype(vr)[]
    if hasrays(vr)
        rays_idx = collect(eachindex(rays(vr)))
        λ = @variable(model, [rays_idx], lower_bound = 0.0)
        nonredundant_elements(vr, model, hull, z, nr_rays, rays_idx, λ)
    end
    return (nr_rays,)
end
function nonredundant_points(vr::VCone, model, hull, z)
    return tuple()
end
function nonredundant_points(vr::VRepresentation, model, hull, z)
    nr_points = pointtype(vr)[]
    if haspoints(vr)
        points_idx = collect(eachindex(points(vr)))
        λ = @variable(model, [points_idx], lower_bound = 0.0)
        @constraint(model, sum(λ) == 1)
        nonredundant_elements(vr, model, hull, z, nr_points, points_idx, λ)
    end
    return (nr_points,)
end


removevredundancy(vr::VEmptySpace, solver) = vr

"""
    removevredundancy(vr::VRepresentation, solver)

Return a V-representation of the polyhedron represented by `vr` all the
elements of `vr` except the redundant ones, i.e. the elements that can
be expressed as convex combination of other ones.
"""
function removevredundancy(vr::VRepresentation, solver)
    model = ParameterJuMP.ModelWithParams(solver)
    z = ParameterJuMP.add_parameters(model, zeros(fulldim(vr)))
    hull = [zero(JuMP.AffExpr) for i in 1:fulldim(vr)]
    # TODO It's much more efficient to remove redundant lines with `removeduplicates`.
    #      Moreover, linearity may have already been detected.
    #      The only advantage over `removeduplicates` is that it does not alter
    #      the lines, it just remove the redundant ones.
    nr_lines = nonredundant_lines(vr, model, hull, z)
    nr_rays = nonredundant_rays(vr, model, hull, z)
    nr_points = nonredundant_points(vr, model, hull, z)
    return vrep(nr_points..., nr_lines..., nr_rays...; d=FullDim(vr))
end
function _fill_hull(hull::Vector{JuMP.AffExpr}, λ, p, idxs)
    for idx in idxs
        x = get(p, idx)
        c = coord(x)
        for i in eachindex(hull)
            JuMP.add_to_expression!(hull[i], c[i], λ[idx])
        end
    end
end

function _filter(f, it)
    # FIXME returns a Vector{Any}
    #collect(Iterators.filter(f, it)) # filter does not implement length so we need to collect
    ret = eltype(it)[]
    for el in it
        if f(el)
            push!(ret, el)
        end
    end
    ret
end
function removevredundancy(vrepit::VIt, hrep::HRep; nl=nlines(hrep), kws...)
    _filter(v -> !isredundant(hrep, v; nl=nl, kws...), vrepit)
end

# Remove redundancy in the V-representation using the H-representation
# There shouldn't be any duplicates in hrep for this to work
function _removevred_withhred(vrep::VRep, hrep::HRep; kws...)
    nl = nlines(vrep)
    typeof(vrep)(
        FullDim(vrep),
        removevredundancy.(vreps(vrep), hrep; nl=nl, kws...)...
    )::typeof(vrep)
end
# Split in two methods to avoid ambiguity with `(::VRepresentation, solver::Any)`
function removevredundancy(vrep::Polyhedron, hrep::HRep; kws...)
    _removevred_withhred(vrep, hrep; kws...)
end
function removevredundancy(vrep::VRepresentation, hrep::HRep; kws...)
    _removevred_withhred(vrep, hrep; kws...)
end

function removehredundancy(hrepit::HIt, vrep::VRep; strongly=false, d=dim(vrep))
    _filter(h -> !isredundant(vrep, h, strongly=strongly, d=d), hrepit)
end

# Remove redundancy in the H-representation using the V-representation
# There shouldn't be any duplicates in vrep for this to work
function removehredundancy(hrep::HRep, vrep::VRep; strongly=false)
    R = BitSet()
    d = dim(hrep, true) # TODO dim(hrep)
    typeof(hrep)(FullDim(hrep),
                 removehredundancy.(hreps(hrep), vrep,
                                    strongly=strongly, d=d)...)
end


#function gethredundantindices(hrep::HRep; strongly=false, solver=Polyhedra.solver(hrep))
#    red = BitSet()
#    for (i, h) in enumerate(hreps(hrep))
#        if ishredundant(hrep, h; strongly=strongly, solver=solver)
#            push!(red, i)
#        end
#    end
#    red
#end
#function getvredundantindices(vrep::VRep; strongly = true, solver=Polyhedra.solver(vrep))
#    red = BitSet()
#    for (i, v) in enumerate(vreps(vrep))
#        if isvredundant(vrep, v; strongly=strongly, solver=solver)
#            push!(red, i)
#        end
#    end
#    red
#end

# V-redundancy
# If p is an H-representation, nl needs to be given otherwise if p is a Polyhedron, it can be asked to p.
# TODO nlines should be the number of non-redundant lines so something similar to dim
function isredundant(p::HRep{T}, v::Union{AbstractVector, Line, Ray}; strongly = false, nl::Int=nlines(p), solver=nothing) where {T}
    # v is in every hyperplane otherwise it would not be valid
    hcount = nhyperplanes(p) + count(h -> v in hyperplane(h), halfspaces(p))
    strong = (isray(v) ? fulldim(p)-1 : fulldim(p)) - nl
    return hcount < (strongly ? min(strong, 1) : strong)
end
# A line is never redundant but it can be a duplicate
isredundant(p::HRep{T}, v::Line; strongly = false, nl::Int=nlines(p), solver=nothing) where {T} = false

# H-redundancy
# If p is a V-representation, nl needs to be given otherwise if p is a Polyhedron, it can be asked to p.
function isredundant(p::VRep{T}, h::HRepElement; strongly = false, d::Int=dim(p), solver=nothing) where {T}
    checkvconsistency(p)
    hp = hyperplane(h)
    pcount = count(p -> p in hp, points(p))
    # every line is in h, otherwise it would not be valid
    rcount = nlines(p) + count(r -> r in hp, rays(p))
    pcount < min(d, 1) || (!strongly && pcount + rcount < d)
end
# An hyperplane is never redundant but it can be a duplicate
isredundant(p::VRep{T}, h::HyperPlane; strongly = false, d::Int=dim(p), solver=nothing) where {T} = false

# H-redundancy
#function ishredundantaux(p::HRep, a, β, strongly, solver)
#    sol = MPB.linprog(-a, p, solver)
#    if sol.status == :Unbounded
#        false
#    elseif sol.status == :Optimal
#        if _gt(sol.objval, β)
#            false
#        elseif _geq(sol.objval, β)
#            if strongly
#                false
#            else
#                true
#            end
#        else
#            true
#        end
#    end
#end
#function ishredundant(p::Rep, h::HRepElement; strongly = false, solver=Polyhedra.solver(p))
#    if islin(h)
#        sol = ishredundantaux(p, h.a, h.β, strongly, solver)
#        if !sol[1]
#            sol
#        else
#            ishredundantaux(p, -h.a, -h.β, strongly, solver)
#        end
#    else
#        ishredundantaux(p, h.a, h.β, strongly, solver)
#    end
#end

######################
# Duplicates removal #
######################
export removeduplicates

"""
    removeduplicates(rep::Representation)

Removes the duplicates in the Representation.

* In an H-representation, it removes the redundant hyperplanes and it remove an halfspace when it is equal to another halfspace in the affine hull.
  For instance, `HalfSpace([1, 1], 1)` is equal to `HalfSpace([1, 0], 0)` in the affine hull generated by `HyperPlane([0, 1], 1])`.
* In a V-representation, it removes the redundant lines and it remove a point (resp. ray) when it is equal to another point (resp. ray) in the line hull.
  For instance, in the line hull generated by `Line([0, 1])`, `[1, 1]` is equal to `[1, 0]` and `Ray([2, 2])` is equal to `Ray([1, 0])`.
"""
function removeduplicates end

# V-duplicates
# Function barrier approach:
# Separate function so that it is compiled with a concrete type for p
function vpupdatedup!(aff, points, p::AbstractVector)
    if !any(point -> (point - p) in aff, points)
        push!(points, p)
    end
end
function vrupdatedup!(aff::VLinearSpace, rays::Vector{<:Ray}, r)
    r = remproj(r, aff)
    if !isapproxzero(r) && !any(ray -> ray ≈ r, rays)
        l = line(r)
        i = findfirst(ray -> line(ray) ≈ l, rays)
        if i === nothing
            push!(rays, r)
        else
            deleteat!(rays, i)
            convexhull!(aff, l)
        end
        return i !== nothing
    else
        return false
    end
end
function premovedups(vrep::VRepresentation, aff::VLinearSpace)
    ps = pointtype(vrep)[]
    for p in points(vrep)
        vpupdatedup!(aff, ps, p)
    end
    tuple(ps)
end

function removeduplicates(vrep::VPolytope)
    typeof(vrep)(FullDim(vrep), premovedups(vrep, emptyspace(vrep))...)
end
function removeduplicates(vrep::VRepresentation, solver = nothing)
    aff, rs = _detectvlinearity(vrep, solver)
    typeof(vrep)(FullDim(vrep), premovedups(vrep, aff)..., aff.lines, rs)
end

# H-duplicates
#function hupdatedup!(hp, hs, h::HyperPlane)
#    if !any(isapprox.(hp, [h]))
#        for (i, s) in enumerate(hs)
#            if hyperplane(s) ≈ h
#                deleteat!(hs, i)
#                break # There should be no duplicate in hp so no need to continue
#            end
#        end
#        push!(hp, h)
#    end
#end
function hupdatedup!(aff::HAffineSpace, hss, h::HalfSpace)
    h = remproj(h, aff)
    if !isapproxzero(h) && !any(hs -> _isapprox(remproj(hs, aff), h), hss)
        hp = hyperplane(h)
        found = false
        for (i, hs) in enumerate(hss)
            # TODO Not enough, e.g.
            # x <= 1
            # y <= 1
            # x + y >= 2
            if hyperplane(hs) ≈ hp
                deleteat!(hss, i)
                found = true
                break # There should be no duplicate in hp so no need to continue
            end
        end
        if found
            intersect!(aff, hp)
        else
            push!(hss, h)
        end
        found
    else
        false
    end
end
function removeduplicates(hrep::HRepresentation{T}) where {T}
    aff = affinehull(hrep, true)
    newlin = true
    hs = halfspacetype(hrep)[]
    while newlin
        newlin = false
        aff = removeduplicates(aff)
        empty!(hs)
        for h in halfspaces(hrep)
            newlin |= hupdatedup!(aff, hs, h)
        end
    end
    typeof(hrep)(FullDim(hrep), aff.hyperplanes, hs)
end
