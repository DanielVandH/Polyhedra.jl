<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extended Formulation · Polyhedra</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Polyhedra</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Index</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../representation/">Representation</a></li><li><a class="tocitem" href="../../polyhedron/">Polyhedron</a></li><li><a class="tocitem" href="../../plot/">Plot</a></li><li><a class="tocitem" href="../../redundancy/">Containment/Redundancy</a></li><li><a class="tocitem" href="../../projection/">Projection/Elimination</a></li><li><a class="tocitem" href="../../optimization/">Optimization</a></li><li><a class="tocitem" href="../../utilities/">Utilities</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Convex hull and intersection/">Convex hull and intersection</a></li><li class="is-active"><a class="tocitem" href>Extended Formulation</a></li><li><a class="tocitem" href="../Minimal Robust Positively Invariant Set/">Minimal Robust Positively Invariant Set</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Extended Formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extended Formulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/examples/Extended Formulation.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Extended-formulation"><a class="docs-heading-anchor" href="#Extended-formulation">Extended formulation</a><a id="Extended-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-formulation" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/JuliaPolyhedra/Polyhedra.jl/gh-pages?filepath=dev/generated/Extended Formulation.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/JuliaPolyhedra/Polyhedra.jl/blob/gh-pages/dev/generated/Extended Formulation.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this notebook, we show how to work with the extended formulation of a polyhedron. The convex hull of the union of polyhedra that are H-represented can be obtained as the projection of a H-representation [Theorem 3.3, B85]. In order to use the resulting polyhedron as a constraint set in an optimization problem, there is no need to compute the resulting H-representation of this projection. Moreover, other operations such as intersection are also implemented between extended H-representations. We illustrate this with a simple example. We start by defining the H-representation of a square with JuMP.</p><p>[B85] Balas, E., 1985. <em>Disjunctive programming and a hierarchy of relaxations for discrete optimization problems</em>. SIAM Journal on Algebraic Discrete Methods, 6(3), pp.466-486.</p><pre><code class="language-julia">using JuMP
model = Model()
@variable(model, -1 &lt;= x &lt;= 1)
@variable(model, -1 &lt;= y &lt;= 1)
using Polyhedra
square = hrep(model)</code></pre><pre class="documenter-example-output">H-representation LPHRep{Float64}:
4-element iterator of HalfSpace{Float64, SparseArrays.SparseVector{Float64, Int64}}:
 HalfSpace(  [1]  =  -1.0, 1.0)
 HalfSpace(  [2]  =  -1.0, 1.0)
 HalfSpace(  [1]  =  1.0, 1.0)
 HalfSpace(  [2]  =  1.0, 1.0)</pre><p>Note that the names of the JuMP variables are used as the names of the corresponding dimensions for the polyhedron <code>square</code>.</p><pre><code class="language-julia">dimension_names(square)</code></pre><pre class="documenter-example-output">2-element Vector{String}:
 &quot;x&quot;
 &quot;y&quot;</pre><p>In the following, <code>diagonal</code> and <code>antidiag</code> are projections of extended H-representations of dimension 7 hence <code>diamond</code> is a projection of an extended H-representation of dimensions 12.</p><pre><code class="language-julia">diagonal = convexhull(translate(square, [-2, -2]), translate(square, [2, 2]))
antidiag = convexhull(translate(square, [-2,  2]), translate(square, [2, -2]))
diamond = diagonal ∩ antidiag</code></pre><pre class="documenter-example-output">Polyhedra.Projection{LPHRep{Float64}, Base.OneTo{Int64}}(HyperPlane(  [1 ]  =  1.0
  [3 ]  =  -1.0
  [5 ]  =  -1.0, 0.0) ∩ HyperPlane(  [2 ]  =  1.0
  [4 ]  =  -1.0
  [6 ]  =  -1.0, 0.0) ∩ HyperPlane(  [1 ]  =  1.0
  [8 ]  =  -1.0
  [10]  =  -1.0, 0.0) ∩ HyperPlane(  [2 ]  =  1.0
  [9 ]  =  -1.0
  [11]  =  -1.0, 0.0) ∩ HalfSpace(  [3 ]  =  -1.0
  [7 ]  =  -3.0, 0.0) ∩ HalfSpace(  [4 ]  =  -1.0
  [7 ]  =  -3.0, 0.0) ∩ HalfSpace(  [3 ]  =  1.0
  [7 ]  =  1.0, 0.0) ∩ HalfSpace(  [4 ]  =  1.0
  [7 ]  =  1.0, 0.0) ∩ HalfSpace(  [5 ]  =  -1.0
  [7 ]  =  -1.0, -1.0) ∩ HalfSpace(  [6 ]  =  -1.0
  [7 ]  =  -1.0, -1.0) ∩ HalfSpace(  [5 ]  =  1.0
  [7 ]  =  3.0, 3.0) ∩ HalfSpace(  [6 ]  =  1.0
  [7 ]  =  3.0, 3.0) ∩ HalfSpace(  [7 ]  =  -1.0, 0.0) ∩ HalfSpace(  [7 ]  =  1.0, 1.0) ∩ HalfSpace(  [8 ]  =  -1.0
  [12]  =  -3.0, 0.0) ∩ HalfSpace(  [9 ]  =  -1.0
  [12]  =  1.0, 0.0) ∩ HalfSpace(  [8 ]  =  1.0
  [12]  =  1.0, 0.0) ∩ HalfSpace(  [9 ]  =  1.0
  [12]  =  -3.0, 0.0) ∩ HalfSpace(  [10]  =  -1.0
  [12]  =  -1.0, -1.0) ∩ HalfSpace(  [11]  =  -1.0
  [12]  =  3.0, 3.0) ∩ HalfSpace(  [10]  =  1.0
  [12]  =  3.0, 3.0) ∩ HalfSpace(  [11]  =  1.0
  [12]  =  -1.0, -1.0) ∩ HalfSpace(  [12]  =  -1.0, 0.0) ∩ HalfSpace(  [12]  =  1.0, 1.0), Base.OneTo(2))</pre><p>Note that the names the first two dimensions are still identical to the names of the JuMP variables and the auxiliary variables have no name.</p><pre><code class="language-julia">dimension_names(diamond.set)</code></pre><pre class="documenter-example-output">12-element Vector{String}:
 &quot;x&quot;
 &quot;y&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;
 &quot;&quot;</pre><p>We don&#39;t need to compute the result of the projection to solve an optimization problem over <code>diamond</code>. For instance, to compute the maximal value that <code>y</code> can take over this polytope with the GLPK solver, we can do as follows. Note that if we use anonymous JuMP variables, the name of the JuMP variables will be the names of the corresponding dimensions of the polyhedron. Therefore, we can retrieve the JuMP variable according to the corresponding dimension name with <code>variable_by_name</code>.</p><pre><code class="language-julia">import GLPK
model = Model(GLPK.Optimizer)
@variable(model, [1:2] in diamond)
x = variable_by_name(model, &quot;x&quot;)
y = variable_by_name(model, &quot;y&quot;)
@objective(model, Max, y)
optimize!(model)
value(x), value(y)</code></pre><pre class="documenter-example-output">(0.0, 2.0)</pre><p>In the optimization problem, above, the auxiliary variables of the extended formulation are transparently added inside a bridge. To manipulate the auxiliary variables, one can use the extended H-representation directly instead of its projection. Note that as the auxiliary dimensions have no name, we cannot use <code>variable_by_name</code> to retrieve the corresponding JuMP variables. We can instead catch the returned value of <code>@variable</code> in some variable <code>v</code> in order to use anonymous JuMP variables while still assigning the created JuMP variables to <code>v</code>.</p><pre><code class="language-julia">import GLPK
model = Model(GLPK.Optimizer)
v = @variable(model, [1:12] in diamond.set)
y = variable_by_name(model, &quot;y&quot;)
@objective(model, Max, y)
optimize!(model)
value.(v)</code></pre><pre class="documenter-example-output">12-element Vector{Float64}:
  0.0
  2.0
 -0.75
 -0.25
  0.75
  2.25
  0.25
 -0.75
  2.25
  0.75
 -0.25
  0.75</pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Convex hull and intersection/">« Convex hull and intersection</a><a class="docs-footer-nextpage" href="../Minimal Robust Positively Invariant Set/">Minimal Robust Positively Invariant Set »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 27 May 2021 22:09">Thursday 27 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
