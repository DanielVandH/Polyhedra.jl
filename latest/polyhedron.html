<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polyhedron · Polyhedra</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Polyhedra</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Index</a></li><li><a class="toctext" href="installation.html">Installation</a></li><li><a class="toctext" href="representation.html">Representation</a></li><li class="current"><a class="toctext" href="polyhedron.html">Polyhedron</a><ul class="internal"><li><a class="toctext" href="#Retrieving-a-representation-1">Retrieving a representation</a></li><li><a class="toctext" href="#Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model-1">Creating a polyhedron from the feasible set of a JuMP model</a></li><li><a class="toctext" href="#Projecting-a-polyhedron-1">Projecting a polyhedron</a></li><li class="toplevel"><a class="toctext" href="#TODO-1">TODO</a></li></ul></li><li><a class="toctext" href="redundancy.html">Redundancy</a></li><li><a class="toctext" href="projection.html">Projection</a></li><li><a class="toctext" href="utilities.html">Utilities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="polyhedron.html">Polyhedron</a></li></ul><a class="edit-page" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/docs/src/polyhedron.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Polyhedron</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Polyhedron-1" href="#Polyhedron-1">Polyhedron</a></h1><p>As seen in the previous section, a polyhedron can be described in 2 ways: either using the H-representation (list of inequalities) or the V-representation (list of points and rays). A typical problem is: Given the H-(or V-)representation of one or several polyhedra, what is the H-(or V-)representation of some polyhedra obtained after some operations on these initial polyhedra. This description is similar to the description usually given to algorithms except that in that case we talk about numbers given in their binary representation and not polyhedra given in their H-(or V-)representation. This motivates the creation of a type representing polyhedra. Just like the abstract type <code>AbstractArray{N,T}</code> represents an <code>N</code>-dimensional array with elements of type <code>T</code>, the abstract type <code>Polyhedron{N,T}</code> represents an <code>N</code>-dimensional polyhedron with elements of coefficient type <code>T</code>.</p><p>There is typically one concrete subtype of <code>Polyhedron</code> by library. For instance, the CDD library defines <code>CDDPolyhedron</code> and the LRS library defines <code>LRSPolyhedron</code>. It must be said that the type <code>T</code> is not necessarily how the elements are stored internally by the library but the polyhedron will behave just like it is stored that way. For instance, when retreiving an H-(or V-)representation, the representation will be of type <code>T</code>. Therefore using <code>Int</code> for <code>T</code> may result in <code>InexactError</code>. For this reason, by default, the type <code>T</code> chosen is not a subtype of <code>Integer</code>.</p><p>Consider the representations <code>hrep</code>, <code>vrep</code> and <code>vrepf</code> created in the preceding section. One can use the CDD library, to create an instance of a concrete subtype of <code>Polyhedron</code></p><pre><code class="language-julia">julia&gt; using CDDLib
julia&gt; polyf = polyhedron(hrep, CDDLibrary())
julia&gt; typeof(polyhf)
CDDLib.CDDPolyhedron{2,Float64}</code></pre><p>We see that the library has choosen to deal with floating point arithmetic. This decision does not depend on the type of <code>hrep</code> but only on the instance of <code>CDDLibrary</code> given. <code>CDDLibrary</code> creates <code>CDDPolyhedron</code> of type either <code>Float64</code> or <code>Rational{BigInt}</code>. One can choose the first one using <code>CDDLibrary(:float)</code> and the second one using <code>CDDLibrary(:exact)</code>, by default it is <code>:float</code>.</p><pre><code class="language-julia">julia&gt; poly = polyhedron(hrep, CDDLibrary(:exact))
julia&gt; typeof(poly)
CDDLib.CDDPolyhedron{2,Rational{BigInt}}</code></pre><p>The first polyhedron <code>polyf</code> can also be created from its V-representation using either of the 4 following lines</p><pre><code class="language-julia">julia&gt; polyf = polyhedron(vrepf, CDDLibrary(:float))
julia&gt; polyf = polyhedron(vrepf, CDDLibrary())
julia&gt; polyf = polyhedron(vrep,  CDDLibrary(:float))
julia&gt; polyf = polyhedron(vrep,  CDDLibrary())</code></pre><p>and <code>poly</code> using either of those lines</p><pre><code class="language-julia">julia&gt; poly = polyhedron(vrepf, CDDLibrary(:exact))
julia&gt; poly = polyhedron(vrep , CDDLibrary(:exact))</code></pre><p>of course, creating a representation in floating points with exact arithmetic works here because we have <code>0.5</code> which is <code>0.1</code> in binary but in general, is not a good idea.</p><pre><code class="language-julia">julia&gt; Rational{BigInt}(1/2)
1//2
julia&gt; Rational{BigInt}(1/3)
6004799503160661//18014398509481984
julia&gt; Rational{BigInt}(1/5)
3602879701896397//18014398509481984</code></pre><h2><a class="nav-anchor" id="Retrieving-a-representation-1" href="#Retrieving-a-representation-1">Retrieving a representation</a></h2><p>One can retrieve an H-representation (resp. V-representation) from a polyhedron using <code>hrep</code> (resp. <code>vrep</code>). The concrete subtype of <code>HRepresentation</code> (resp. <code>VRepresentation</code>) returned is not necessarily the same that the one used to create the polyhedron. As a rule of thumb, it is the representation the closest to the internal representation used by the library.</p><pre><code class="language-julia">julia&gt; hrep = hrep(poly)
julia&gt; typeof(hrep)
Polyhedra.LiftedHRepresentation{2,Rational{BigInt}}
julia&gt; hrep = SimpleHRepresentation(hrep)
julia&gt; typeof(hrep)
Polyhedra.SimpleHRepresentation{2,Rational{BigInt}}
julia&gt; hrep.A
3x2 Array{Rational{BigInt},2}:
  1//1   1//1
  1//1  -1//1
 -1//1   0//1
julia&gt; hrep.b
3-element Array{Rational{BigInt},1}:
 1//1
 0//1
 0//1
julia&gt; vrep = vrep(poly)
julia&gt; typeof(vrep)
Polyhedra.LiftedVRepresentation{2,Rational{BigInt}}
julia&gt; vrep = SimpleVRepresentation(vrep)
julia&gt; typeof(vrep)
Polyhedra.SimpleVRepresentation{2,Rational{BigInt}}
julia&gt; vrep.V
3x2 Array{Rational{BigInt},2}:
 1//2  1//2
 0//1  1//1
 0//1  0//1

julia&gt; vrep.R
0x2 Array{Rational{BigInt},2}</code></pre><h2><a class="nav-anchor" id="Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model-1" href="#Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model-1">Creating a polyhedron from the feasible set of a JuMP model</a></h2><p>A typical application of polyhedral computation is the computation of the set of extreme points and rays of the feasible set of an optimization problem. This comes from the fact that given a minimization of a concave function (or maximization of a convex function) on a convex feasible set (e.g. Linear Programming), we are either in the following three situations:</p><ul><li><p>The feasible set is empty, i.e. the problem is infeasible.</p></li><li><p>An extreme ray is optimal, i.e. the problem is unbounded (or it may also be bounded if the objective is constant along the ray).</p></li><li><p>An extreme point is optimal.</p></li></ul><p>A JuMP model is treated by <code>polyhedron</code> just like any H-representation. For example, the hypercube of dimension <code>n</code> can be created as follows</p><pre><code class="language-julia">m = Model()
@variable(m, 0 ≤ x[1:n] ≤ 1)

poly = polyhedron(m, CDDLibrary(:exact))</code></pre><p>In fact, the MathProgBase representation of the feasible set of a linear program:</p><div>\[\begin{align*}
  lb \leq Ax \leq ub\\
  l \leq x \leq u\\
\end{align*}\]</div><p>has <code>LPHRepresentation</code> as a corresponding H-representation. A JuMP Model can be converted to this representation using <code>LPHRepresentation(m)</code>.</p><h2><a class="nav-anchor" id="Projecting-a-polyhedron-1" href="#Projecting-a-polyhedron-1">Projecting a polyhedron</a></h2><p>Consider the polyhedron created in the beginning of this section. As a reminder, it represents the following H-representation:</p><div>\[\begin{align*}
  x_1 + x_2 &amp;\leq 1 \\
  x_1 - x_2 &amp;\leq 0 \\
  x_1 &amp; \geq 0.
\end{align*}\]</div><p>One can verify that for any <span>$0 \leq x_2 \leq 1$</span>, there exists a value <span>$x_1$</span> such that <span>$(x_1, x_2)$</span> is in this polyhedron. This means that the H-representation obtained by eliminating <span>$x_1$</span> is:</p><div>\[\begin{align*}
  x_1 &amp; \leq 1 \\
  x_1 &amp; \geq 0.
\end{align*}\]</div><p>where <span>$x_1$</span> in the H-representation above represents <span>$x_2$</span> in the previous one. This can be obtained as follows</p><pre><code class="language-julia">julia&gt; poly_x2 = eliminate(poly, [1])
julia&gt; hrep(poly_x2)
H-representation
begin
 2 2 rational
 1//1 -1//1
 0//1 1//1
end</code></pre><p>There is two methods of computing the elimination implemented in CDDLib: Fourier-Motzkin elimination and block elimination. As written by K. Fukuda in CDD&#39;s documentation, &quot;[Block elimination] might be a faster way to eliminate variables than the repeated [Fourier-Motzkin elimination] when the number of variables to eliminate is large&quot;. You can specify the method to use as a third argument, e.g. <code>eliminate(poly, [1], :FourierMotzkin)</code>, <code>eliminate(poly, [1], :BlockElimination)</code>. A third method can be chosen: <code>:ProjectGenerators</code>. It computes the V-representation and then project each of its elements. This is the method of choice when the V-representation is already computed.</p><p>If nothing is specified as in the block of code above, the behavior depends on the polyhedral library. If neither Fourier-Motzkin nor block elimination is implemented or if the V-representation is already computed then <code>:ProjectGenerators</code> is chosen. Otherwise, Polyhedra lets the library decide. In CDDLib, <code>:FourierMotzkin</code> is chosen when only the last dimension needs to be eliminated and <code>:BlockElimination</code> is chosen otherwise. Note that CDDLib only supports projecting the last trailing dimensions.</p><h1><a class="nav-anchor" id="TODO-1" href="#TODO-1">TODO</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.hrepiscomputed" href="#Polyhedra.hrepiscomputed"><code>Polyhedra.hrepiscomputed</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hrepiscomputed(p::Polyhedron)</code></pre><p>Returns whether the H-representation of this polyhedron has been computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/82586d5aa88445d49c95a6e2f39833cc9df1f796/src/operations.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Polyhedra.vrepiscomputed" href="#Polyhedra.vrepiscomputed"><code>Polyhedra.vrepiscomputed</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vrepiscomputed(p::Polyhedron)</code></pre><p>Returns whether the V-representation of this polyhedron has been computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/82586d5aa88445d49c95a6e2f39833cc9df1f796/src/operations.jl#L30-L34">source</a></section><footer><hr/><a class="previous" href="representation.html"><span class="direction">Previous</span><span class="title">Representation</span></a><a class="next" href="redundancy.html"><span class="direction">Next</span><span class="title">Redundancy</span></a></footer></article></body></html>
